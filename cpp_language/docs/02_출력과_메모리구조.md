
# 📚 02_C++ 문자열 출력과 메모리 구조 정리

학습한 내용을 기반으로, C++에서의 문자열 출력과 관련된 개념들을 정리한 문서입니다.

---

## 🔹 `std::string` vs `const char*` 구조 비교

| 항목 | `std::string` | `const char*` |
|------|---------------|----------------|
| 문자열 저장 위치 | Heap (동적 메모리) | .rodata (읽기 전용 데이터 영역) |
| 변수 위치 | Stack (객체 자체) | Stack (포인터 변수) |
| 수정 가능 여부 | 가능 (멤버 함수로) | 불가 (보통 리터럴) |
| 타입 | 객체 타입 (클래스) | 포인터 타입 |
| 문자열 포맷 | C++ 스타일 | C 스타일 (null-terminated) |

---

## 🔹 `.c_str()`의 역할

```cpp
std::string name = "Umi";
printf("%s", name.c_str());
```

- `.c_str()`은 `std::string` 내부에 저장된 힙 메모리 문자열의 **주소를 const char* 형식으로 포장해서 반환**한다.
- 데이터의 **복사나 변환은 일어나지 않음**.
- 반환된 포인터는 C 스타일 문자열처럼 사용 가능 (`printf`, `strcpy` 등).
- `std::string` 객체가 유효한 동안에만 사용 가능하며, 객체 수정 시 주소가 바뀔 수 있음.

---

## 🔹 메모리 구조 다이어그램

### C 스타일 문자열

```
[ .rodata 영역 ]
"Hello\0"

[ stack 영역 ]
const char* cstr ───────▶ "Hello\0"
```

### C++ 스타일 문자열

```
[ stack 영역 ]
std::string name
└── char* ptr ───────┐
    size             │
    capacity         ▼
                  [ heap 영역 ]
                  "Hello\0"
```

---

## 🔹 중요한 포인트 요약

- `std::string`은 내부에 `char*` 포인터를 포함하고 있고, 그 포인터가 heap에 있는 문자열 데이터를 가리킨다.
- `.c_str()`은 그 포인터를 **const char* 형식으로 안전하게 노출**하는 함수일 뿐이다.
- `printf` 등 C 스타일 함수와 연동할 때 사용된다.
- 주의: `.c_str()` 결과는 임시 값이 아니며, **객체가 살아있는 동안 유효**하지만, 객체가 파괴되거나 문자열이 수정되면 무효화될 수 있다.

---

## ✅ 결론

```
std::string 객체는 힙에 문자열을 저장하고,
.c_str()은 그 문자열의 주소를 const char* 형태로 노출시킨다.
printf는 그 주소값을 받아 문자열을 출력한다.
```

---

