# 📚 std::vector 완전 정리

## 1. std::vector란 무엇인가?
std::vector는 C++ 표준 라이브러리(STL, Standard Template Library)에 포함된 동적 배열 컨테이너임.

일반적인 배열(int arr[10] 등)과 달리, 크기가 자동으로 조정되는 특징을 가짐.

배열처럼 연속적인 메모리 공간을 사용하여 빠른 인덱스 접근(O(1))이 가능함.

데이터 추가, 삭제 시 내부에서 메모리를 자동 관리함.

## 2. 주요 특징

| 특징 | 설명 |
| --- | --- |
| 동적 크기 조절	| 원소 추가/삭제에 따라 자동으로 크기가 변함 |
| 연속적 메모리	| 배열과 마찬가지로 메모리가 연속되어 있음 |
| 빠른 접근	| 인덱스를 통한 직접 접근이 O(1) 시간복잡도를 가짐 |
| 삽입/삭제 비용	| 끝에서의 삽입/삭제는 빠름 (O(1)), 중간 삽입/삭제는 느림 (O(N)) |
| 템플릿 기반	| 다양한 타입을 지원 (vector<int>, vector<double> 등) |

## 3. 기본 사용법

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> v; // 빈 벡터 생성

    v.push_back(10);    // 10 추가
    v.push_back(20);    // 20 추가
    v.push_back(30);    // 30 추가

    // 인덱스 접근
    std::cout << v[0] << std::endl; // 10 출력
    std::cout << v.at(1) << std::endl; // 20 출력 (범위 체크 포함)

    // 전체 출력
    for (int i = 0; i < v.size(); i++) {
        std::cout << v[i] << ' ';
    }
    std::cout << std::endl;

    return 0;
}

```

## 4. 주요 멤버 함수 정리

| 함수 | 설명 |
| --- | --- |
| push_back(value) | 벡터의 맨 뒤에 요소 추가 |
| pop_back() | 벡터의 맨 뒤 요소 삭제 |
| size() | 현재 요소의 개수 반환 |
| empty() | 벡터가 비어 있는지 여부 반환 |
| clear() | 모든 요소 삭제 |
| at(index) | 인덱스를 통해 요소 접근 (범위 검사 포함) |
| front() | 첫 번째 요소 접근 |
| back() | 마지막 요소 접근 |
| insert(pos, value) | 특정 위치에 요소 삽입 |
| erase(pos) | 특정 위치 요소 삭제 |
| resize(new_size) | 벡터 크기 변경 |
| reserve(capacity) | 메모리 여유 공간을 미리 확보 |
| capacity() | 현재 할당된 메모리 용량 확인 |

## 5. 메모리 관리 (capacity와 size)
- size(): 현재 벡터에 실제 저장된 원소 개수를 의미함.
- capacity(): 벡터가 할당해둔 메모리 공간의 크기를 의미함.
- 원소를 추가할 때, size가 capacity를 초과하면 메모리를 재할당하고, 보통 2배로 늘림.

- 재할당 시 모든 원소를 새 메모리로 복사하기 때문에 비용이 발생할 수 있음.

``` cpp
std::vector<int> v;
v.reserve(1000); // 1000개를 위한 메모리 미리 확보
```
- reserve()를 사용하면, 예상 삽입량이 많을 때 재할당 비용을 줄일 수 있음.

## 6. 시간복잡도 요약

| 연산 | 시간복잡도 |
| --- | --- |
| 인덱스 접근 | O(1) |
| push_back (평균) | O(1) |
| push_back (재할당) | O(N) |
| pop_back | O(1) |
| insert/erase(중간) | O(N) |

## 7. 벡터 사용 시 주의할 점

- 중간에 원소를 삽입/삭제하는 경우, 모든 원소를 이동해야 하므로 시간이 오래 걸릴 수 있음.

- 메모리 재할당이 발생할 때마다 기존 데이터를 복사해야 하므로, 빈번한 삽입에는 부적합함.

- 따라서 "추가와 끝쪽 삭제"가 주로 필요한 경우에 가장 효율적임.

## 8. 심화: std::vector의 메모리 최적화

- 벡터는 필요 이상으로 메모리를 확보할 수 있음 (capacity > size).

- 모든 작업이 끝난 후, 메모리를 딱 맞게 줄이고 싶을 때는 shrink_to_fit() 사용 가능.

```cpp
std::vector<int> v = {1,2,3,4,5};
v.reserve(1000); // 메모리 크게 확보
v.shrink_to_fit(); // 실제 size에 맞게 메모리 최적화
```

- 단, shrink_to_fit()은 "권장 사항"일 뿐 필수 구현이 아님(플랫폼에 따라 무시될 수 있음).

## 📝 std::vector의 특징 요약

> - **동적 크기 조절** 가능
> - **빠른 인덱스 접근** 가능
> - **메모리 재할당**을 통해 확장
> - **C++ 표준 라이브러리 STL(Standard Template Library)의 대표적인 컨테이너 중 하나 (C++ 표준 동적 배열 컨테이너)**
> 
> *그러나 중간 삽입/삭제가 빈번하면 std::list와 같은 다른 컨테이너를 고려해야 함.*

## vector 바로 알기

1. **vector는 "함수"가 아니라 "클래스(자료구조)"** 이다. 내부적으로 **동적할당(new/delete)을 써서 힙 메모리를 관리**한다.
2. `std::vector<int> v;`
- std::vector<자료형> 변수명;
- 빈 벡터를 생성하는, 기본적인 벡터 선언 방법
- 문자열을 선언할 때는, `std::vector<char*>`도 가능 (char* 포인터 배열) 
- 하지만 요즘은 `**std::vector<std::string>**`을 더 많이 사용
- C++에서는 문자열을 char* 대신 std::string으로 다루는 걸 권장
- `std::vector<int> v;`에서 `v`는 사용자가 정하는 변수 이름. (v1, v2 다 가능)
3. `v.push_back(10);`
- 벡터의 맨 뒤에 요소를 추가하는 멤버 함수
4. vector는 링크드 리스트 처럼 원소마다 포인터를 저장하는 구조가 아님
- vector는 "배열처럼 메모리를 한 줄로 쭉 잡아" 놓는다. (연속된 메모리 공간)
- 포인터로 연결하는 게 아니라, 내부에 커다란 하나의 배열을 관리
- 크기를 늘려야 할 때는 **새 메모리를 할당하고, 기존 데이터를 복사한 후 이전 메모리를 버림**
- 즉, **"포인터 체인이 아니라 커다란 박스를 쓰고, 박스가 작으면 더 큰 박스로 옮기는 형식."**
5. **인덱스 연산 가능**
- 연속된 메모리이기 때문에 주소 연산(pointer 연산) 으로 인덱스를 계산
- `v[3] = *(시작 주소 + 3);` 이런 식으로 주소를 이동해서 값에 접근
6. **v[1]와 v.at(1)의 차이**

| 구분 | v[1] | v.at(1) |
|:---|:---|:---|
| 접근 방식 | 단순 인덱스 접근 | 인덱스 접근 + 범위 검사 |
| 범위 초과 시 | 프로그램이 비정상 종료할 수 있음 (undefined behavior) | 예외(Exception, std::out_of_range)를 던짐 |
| 속도 | 빠름 (추가 검사 없음) | 느릴 수 있음 (범위 체크 overhead 존재) |
| 사용 추천 상황 | 범위를 확실히 알고 있을 때 | 범위를 모를 때, 안전한 코드가 필요할 때 |

7. **v.size() 를 통해 사이즈 연산 가능**
- `v.size()`의 반환 타입 : size_t
- size_t 의 typedef : **부호 없는 정수형(시스템에 따라 보통 unsigned int(32비트 환경) / unsigned long 또는 unsigned long long(64비트 환경)으로 정의됨)**

---

# std::vector의 내부 구조 이해

## 1. 기본 아이디어
- vector는 '커다란 연속된 메모리 공간'을 할당해서 관리.
- 마치 **"크게 잡아놓은 배열"처럼 데이터를 차곡차곡 저장.**

### 📦 비유하자면:
> "큰 택배 박스 하나에 물건(데이터)을 순서대로 넣고,
> 박스가 가득 차면 더 큰 박스를 새로 사서 옮기는 것" 과 같다.

## 2. 주요 포인터 타입 변수
- 벡터는 힙에 할당된 벡터의 데이터 배열을 가리키고 관리하기 위해 내부적으로 `_M_start`, `_M_finish`, `_M_end_of_storage` 등의 포인터 변수들을 활용한다.

| 내부 포인터 | 의미 |
|:---|:---|
| `start` (`_M_start`) | 벡터 데이터가 저장된 **메모리 시작 주소** |
| `finish` (`_M_finish`) | 현재 **데이터가 끝난 위치의 다음 주소** |
| `end_of_storage` (`_M_end_of_storage`) | **할당된 전체 메모리의 끝 주소** (capacity 끝) |

### 설명
- `start` : 벡터가 실제로 데이터를 저장하기 시작하는 메모리 위치를 가리킨다.
- `finish` : **마지막 데이터 다음**을 가리켜서, 현재 데이터 개수(size)를 계산할 때 사용된다.
- `end_of_storage` : 현재 벡터가 할당해둔 메모리 공간의 끝을 가리킨다. (`capacity`를 나타냄)

### 메모리 그림은 예시

```
start         finish               end_of_storage
 ↓              ↓                        ↓
[10][20][30][ ][ ][ ][ ][ ][ ][ ]
```

- [10][20][30] → 데이터가 들어간 부분
- [ ][ ][ ] → 아직 비어있는, 여유 있는 공간
- 필요하면 여기에 계속 추가(push_back)할 수 있다.

## 3. 메모리 확장(재할당) 과정
- push_back()을 하다가 여유공간이 다 차면 어떻게 할까?
- ✅ 새로운 더 큰 공간을 마련해서 데이터 전체를 복사한다.

- 예시: (수용 가능량 capacity = 3이 꽉 찼을 때)
1. 새 공간 할당: **보통 현재 크기의 2배 크기로 새 배열을 만든다.** (ex: 3 → 6)
2. 기존 데이터 복사: [10][20][30]을 새 배열로 복사한다.
3. 새 데이터 추가: 새로운 데이터(예: 40)를 복사한 배열에 이어 붙인다.
4. 기존 메모리 해제: 원래 있던 작은 배열은 없앤다.

## 4. 인덱스 접근이 빠른 이유
- 왜 v[3] 이런 식으로 빠르게 접근할 수 있을까?

- 메모리 공간이 연속되어 있어서, `(시작주소) + (원소 크기 × 인덱스)` 로 바로 계산할 수 있기 때문이다.
- `*(start + (i * sizeof(자료형)))` 이런 식으로 메모리에서 바로 원하는 위치를 찾을 수 있다.
- 따라서 인덱스 접근이 아주 빠르다.

