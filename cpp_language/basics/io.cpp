// #include <stdio.h>

// int main() {
//     char name[30];
//     int age;

//     printf("이름을 입력하세요: ");
//     scanf("%s", name);

//     printf("나이를 입력하세요: ");
//     scanf("%d", &age);

//     printf("안녕하세요, %s님! 당신은 %d살이군요.\n", name, age);

//     return 0;
// }

#include <iostream>

int main() {
    std::string name;
    int age;

    std::cout << "이름을 입력하세요: ";
    std::cin >> name;               // 버퍼 오버플로우 걱정 없음?
    std::cout << "나이를 입력하세요: ";
    std::cin >> age;                // 오, C++ 의 입출력 객체는 형식지정자를 일일히 지정해주지 않아도 되네?
    std::cout << "안녕하세요, " << name << "님! 당신은 " << age << "살이군요." << std::endl;

}

// std::cin >> name; 이 버퍼 오버플로우 걱정이 없는 이유
// std::cin은 string 객체를 사용했을 때 내부적으로 입력 버퍼의 사이즈를 고려해서
// 자동으로 메모리를 관리해주기 때문에,
// C에서 흔한 char name[30]; 같은 고정된 버퍼 크기로 인한 오버플로우 걱정이 없음.

// name에는 공백 전까지의 문자열이 저장됨.
// std::string은 동적 메모리 할당을 통해 필요한 만큼 메모리를 자동으로 확장함.

// 공백을 기준으로 끊기기 때문에 "홍 길동"처럼 공백 포함된 이름은 첫 단어만 읽는다.
// 따라서 이런 경우엔 std::getline(std::cin, name);을 써야 전체 문장을 읽을 수 있다.

// C++의 cin, cout은 타입에 맞는 함수가 자동으로 오버로드되어 있기 때문에, %d, %s, %f 같은 형식 지정자가 필요 없다.
// 이는 C++의 강력한 타입 시스템 + 함수 오버로딩 + 연산자 오버로딩 덕분!

// C++에서 std::string이 힙 메모리를 사용하는 것과, 입력 버퍼의 크기를 자동으로 관리하는 것은 밀접한 관련이 있다.

// std::string 은 어디에 데이터를 저장할까?
// 내부적으로는 문자열 데이터를 힙(heap) 메모리에 동적 할당한다. 문자열이 커지면 필요한 만큼 메모리를 재할당하며 확장할 수 있다.
// ✔ 즉, 고정된 크기의 char name[30]이 아니기 때문에 입력값이 29자를 넘는다고 해도 오버플로우가 발생하지 않음
// 자동으로 더 큰 메모리를 heap에서 재할당함

