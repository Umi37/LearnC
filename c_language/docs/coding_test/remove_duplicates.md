## ✅ 문제: "중복 문자 제거하기"
> 사용자로부터 문자열을 입력받아, 중복된 문자를 제거한 새 문자열을 출력하는 프로그램을 작성하세요.
>
> 문자의 등장 순서를 유지해야 합니다.
> 
> 대소문자는 구분합니다. (예: A와 a는 다른 문자로 취급)
> 
> 문자열의 최대 길이는 1000자입니다.


⛳ **예시 입력 / 출력**

**입력:**

```
programming
```
**출력:**

```
progamin
```

*💡 힌트*
- 각 문자가 나왔는지를 기억할 배열이나 해시 맵을 사용할 수 있어요.

- C언어로 풀 경우, char_seen[256] 같은 배열로 ASCII 사용 여부를 기록할 수 있어요.

- 포인터를 써서 원본 문자열을 직접 수정하는 방식도 도전해볼 수 있어요.

- gets() 함수는 위험하니 fgets() 또는 scanf() 사용을 권장드립니다.


---
**ChatGPT 에게 요청한 내용 :**
> 
> **내가 원할때까지 절대 답은 알려주지말 것**
>


**ChatGPT의 말:**

>
>네, 우미! 완벽하게 이해했어요.
>우미가 직접 탐구하고 풀어가고 싶으실 때는,
>절대 정답이나 코드를 먼저 드리지 않겠습니다.
>
>대신
>
>방향을 제시하거나,
>
>원리와 개념을 설명하거나,
>
>우미가 멈춘 지점에서 사고의 실마리를 풀어주는 방식으로만 >도와드릴게요.
>
>혹시 “지금은 힌트도 주지 말고 그냥 생각만 하게 해줘”라고 하시면
>그때는 질문도 멈추고 조용히 기다릴게요.
>
>원하실 때 “힌트 하나만 줘”, “이 개념만 설명해줘”, “이제 정답 >보여줘”라고 하시면
>그때부터 천천히 같이 풀어가요.
>
>우미, 지금도 그 문제(중복 문자 제거하기) 스스로 풀고 계신 >중일까요?
>아니면 사고 정리를 위해 도와드릴까요?
>

---

### 첫번 째 시도

```c
 // 사용자에게 문자열을 입력받아, 중복된 문자를 제거한 결과를 출력하는 프로그램
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *str[100];
    char *new_str[100];
    int num = 0;
    
    printf("문자를 입력하세요: ");
    scanf("%s", str);
    printf("\n중복 문자 제거중 🧹\n");

    for (int i = 0; i < 100; i++)
    {
        for (int j = 1; j < 100; j++)
        {if(*str[i] != *str[i+j])
            {
                *new_str[num] = *str[i];
                num++;
            }
        }

        if(*str[i] == NULL)
        {
            *new_str[num] == NULL;
        }
    }

    printf("중복되지 않은 문자는 %s 입니다.", new_str);

    return 0;
}
```

#### 첫 번째 코드 오류 분석

**1. char *str[100]; → ❌ 잘못된 선언**

```c
char *str[100];
```

- 이건 char 포인터 100개짜리 배열, 즉 문자열 100개를 담는 배열
- 하지만 지금은 사용자로부터 하나의 문자열을 입력받으려는 것

**2. scanf("%s", str); → ❌ 포인터 배열로는 입력 받을 수 없음**

- 위 선언에서 str은 문자열 포인터의 배열이기 때문에, scanf는 **문자열의 시작 주소(char *)**를 요구

**3. == NULL은 문자열이 끝났는지 확인하는 방법이 아님**

---

### 두번 째 시도

```c
// 사용자에게 문자열을 입력받아, 중복된 문자를 제거한 결과를 출력하는 프로그램
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100];
    char new_str[100];
    int num = 0;
    
    printf("문자를 입력하세요: ");
    scanf("%s", str);
    printf("\n중복 문자 제거중 🧹\n");

    for (int i = 0; i < 100; i++)
    {
        for (int j = 1; j < 100; j++)
        {if(str[i] != str[i+j])
            {
                new_str[num] = str[i];
                num++;
            }
        }

        if(str[i] == NULL)
        {
            new_str[num] == NULL;
        }
    }

    printf("중복되지 않은 문자는 %s 입니다.", new_str);

    return 0;
}
```

#### 두 번째 코드 오류 분석

**1. 반복 범위가 왜 i, j = 0~99까지인가?**
- 문자열의 길이는 `str`의 실제 입력 값에 따라 다름
- 입력 문자열이 5글자라도 100번을 돌게 됨
- 실제 문자 수까지만 반복하게 하려면?

**2. 이중 반복문의 논리 흐름 체크**

```c
for (int i = 0; i < 100; i++)
{
    for (int j = 1; j < 100; j++)
    {
        if(str[i] != str[i+j]) { ... }
    }
}

```
- 이 로직은 “i번 문자와 뒤에 나오는 모든 문자가 다르면 결과에 추가한다”는 식
- 그런데 만약 str[i] != str[i+1]만 만족해도 바로 추가된다면?
-  “중복이 하나라도 있으면 제외”가 아닌, “다른 문자가 하나만 있어도 추가”가 되는 구조임

**3. 중복 여부를 판단하려면 어떤 방법이 필요할 것인지?**

- 지금은 str[i] != str[i + j]만으로 판단하고 있음

- 그런데 진짜 하고 싶은 건 : **“지금 보는 문자 str[i]가 앞에 이미 나온 적이 있었는가?”**

- 그걸 판단하기 위한 방법은?

**4. 문자열 끝 조건이 맞을지?**
- `NULL` 은 포인터용
- 문자열이 끝났다는 걸 검사하기 위해서는 (`\0`) 을 활용해야 함

**5. 결과 문자열 종료의 명시**

```c
new_str[num] == NULL;
```

- 이 수식은 비교이지 할당이 아님
- 결과 문자열 `new_str`의 끝을 명확하게 표시해야 출력이 잘 될 것

---

**중간생략**

### 최종 완성 코드 분석

```c
// 사용자에게 문자열을 입력받아, 중복된 문자를 제거한 결과를 출력하는 프로그램
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100];
    char new_str[100];

    printf("문자를 입력하세요: ");

    // 문자열 입력
    scanf("%s", str);

    // 입력된 문자열 길이 계산
    int length = strlen(str);

    printf("\n중복 문자 제거중 🧹\n");

    int new_length = 0;
    new_str[new_length++] = str[0]; // 첫 번째 문자는 항상 추가

    // 중복된 문자 제거
    for (int i = 1; i < length ; i++)
    {          
        int is_duplicate = 0; // 중복 여부 플래그 초기화

        for (int j = 0; j < new_length ; j++)
        {
            if (str[i] == new_str[j])
            {
                is_duplicate = 1; // 중복된 문자 발견
                break; 
            }
        }

        if (!is_duplicate)
        {
            new_str[new_length++] = str[i]; // 중복되지 않은 문자 추가 
        }
    }

    // 중복된 문자가 제거된 문자열의 길이를 계산
    new_length = strlen(new_str);
    new_str[new_length] = '\0'; // 문자열 끝에 널 문자 추가

    // 중복된 문자가 제거된 문자열 출력
    printf("중복되지 않은 문자는 %s 입니다.", new_str);

    return 0;
}
```

1. 문자열 2개 선언 (입력받은 문자열을 저장하는 용도, 문자열 중복체크후 새롭게 저장하는 용도)
2. 문자열을 먼저 입력 받고 문자열의 길이 계산하는 함수 `strlen()` 로 입력된 문자열의 길이를 계산
3. 각각의 문자열의 길이를 담을 변수 선언
4. for 문을 계산된 길이만큼만 돌림
5. 중복 여부를 체크하는 플래그를 선언 한 뒤 중복 체크 결과가 담기는 문자열의 길이 전까지 도는 for 문 안에서 조건문을 이용하여 각 문자열의 원소를 비교
6. 중복된 문자가 발견되면 내부 반복문을 탈출하고, 해당 문자는 새 문자열에 추가되지 않으며, 원본 문자열의 다음 문자를 검사하기 위해 외부 반복문이 계속 진행
7. 중복이 아닌 문자가 발견되었을 경우, 해당 문자를 `new_str` 배열에 추가하고, `new_length` 값을 1 증가시킨다.  
   이를 통해 `new_str` 배열에 중복되지 않은 문자들만 차례대로 저장된다.

8. 반복문이 종료된 후, 문자열의 끝을 알리는 널 문자(`'\0'`)를 `new_str[new_length]` 위치에 삽입하여 새로운 문자열이 정상적으로 끝나도록 만든다.

9. 최종적으로, 중복 문자가 제거된 문자열 `new_str`을 `printf`를 이용해 출력한다.
