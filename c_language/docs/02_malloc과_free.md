# 📚 malloc과 free에 대한 정리

C 언어에서 메모리 동적 할당과 해제를 담당하는 `malloc()`과 `free()`는 단순한 함수 호출이 아니라 **메모리 관리 시스템과의 직접적인 상호작용**이다.

---

## 🔹 1. `malloc()`과 `free()`의 기본 개념

- `malloc(size)`는 힙에서 `size`만큼의 메모리를 **동적으로 할당**한다.
- `free(ptr)`은 `ptr`이 가리키는 **힙 메모리를 해제**한다.

---

### ✅ malloc은 항상 "주소"를 반환한다
- malloc(size)는 힙 메모리 영역에서 size 바이트만큼 공간을 할당하고,
- 할당된 메모리 블록의 시작 주소를 반환한다.

- 반환되는 주소를 받아야 하므로,
- 포인터(pointer) 타입 변수로 받아야 한다.

---

**🎯 코드 예시**

```c
char* p = (char*)malloc(100);
```

---

| 동작        | 설명                                |
|-------------|-------------------------------------|
| malloc(100) | 힙 메모리에서 100바이트 공간 확보    |
| (char*)     | malloc이 반환하는 void*를 char*로 형변환 |
| char* p     | 할당된 메모리 블록의 시작 주소를 저장하는 포인터 |

---

### 🧠 포인터로 받지 않으면?

```c
char p;
p = malloc(100);  // ❌ 오류 발생!
```

- malloc()은 주소(void*)를 반환하는데,
- char 타입 변수는 주소를 담을 수 없다.
- 타입이 안 맞아 컴파일 오류 발생!

---

### 📌 malloc 사용 시 타입 변환 주의

| 메모리에 저장할 데이터 | 포인터 타입 | malloc 호출 예시 |
|-------------------|----------|----------------|
| char 데이터 | char* | (char*)malloc(바이트 수) |
| int 데이터 | int* | (int*)malloc(sizeof(int) * 개수) |
| 구조체 데이터 | struct MyStruct* | (struct MyStruct*)malloc(sizeof(struct MyStruct)) |


✅ malloc()은 void*를 반환하기 때문에,
✅ 원하는 타입 포인터로 명시적으로 캐스팅하는 것이 좋다.

---

### ✨ 비유로 쉽게 기억하기
- malloc은 "공간을 마련해주고 주소만 알려주는 부동산 중개인"
- 포인터는 "그 주소를 기억하는 열쇠"

🔑 열쇠(포인터)가 없으면, 공간(메모리)을 사용할 수 없다!

---

### ✅ 최종 한 줄 요약
- malloc은 항상 메모리 공간의 시작 주소를 반환하므로, 반드시 포인터 타입 변수로 받아야 한다.



---

## 🔹 2. 메모리 영역과 생명주기 비교

| 메모리 영역         | 예시                       | 생명주기                    |
|----------------------|----------------------------|-----------------------------|
| 스택 (stack)         | 함수 내 지역 변수           | 함수 종료 시 자동 해제      |
| 힙 (heap)            | `malloc()`으로 할당한 메모리| `free()` 호출 시 해제       |
| 데이터 영역 (static) | `static char str[] = ...`  | 프로그램 종료 시까지 유지  |

---

## 🔹 3. `char*` 반환의 의미

- 문자열은 배열이므로 **배열 전체를 반환할 수 없고**, 배열의 시작 주소인 `char*`를 반환해야 한다.
- 반환한 포인터는 **유효한 힙 또는 정적 메모리 영역**을 가리켜야 한다.

---

## 🔹 4. 함수 내부에서 선언된 배열 반환의 위험성

```c
char* func() {
    char str[] = "hello";
    return str;  // ❌ 위험! 함수 종료 시 str은 사라짐
}
```

- `str`은 스택에 저장되며, 함수 종료 시 사라짐
- 해당 주소를 반환하면 **댕글링 포인터**가 되어 **정의되지 않은 동작(UB)** 발생

---

## 🔹 5. 안전한 문자열 반환 방식

```c
char* func() {
    char* str = malloc(100);
    strcpy(str, "hello");
    return str;  // ✅ 안전! 힙 메모리는 함수가 끝나도 유지됨
}
```

- 또는 `static char str[] = "hello";`를 사용해 정적 메모리에서 반환할 수도 있음

---

## 🔹 6. 왜 `free()`를 중복 호출하면 안 되는가?

- 이미 해제된 주소를 다시 해제하면  
  👉 **힙 메모리 관리 정보(메타데이터)**가 손상될 수 있음
- 결과:
  - **Segmentation fault**
  - **힙 파괴**
  - **예측 불가능한 동작**
- ✅ `free()`는 **정확히 한 번만 호출**해야 하며,  
  그 이후에는 해당 포인터를 **사용하지 않아야** 합니다.

---

## 🔹 7. 비유로 본 이해

- `malloc`은 **컨테이너 가건물을 짓고 주소를 부여하는 것**
- `free`는 **그 건물을 철거하는 것**
- 이미 철거된 곳을 다시 철거하면  
  👉 **없는 건물을 철거하려는 위험한 동작**
- 철거하지 않은 한, 그 건물(메모리)은 살아 있고 유효함

---

## 🔹 8. `free()` 이후 포인터를 사용하면?

- 포인터는 주소값을 **여전히 가지고 있지만**,  
  그 주소는 **이제 의미 없는 공간** (무주공산)이 됨
- 이후 사용 시 → **댕글링 포인터** 발생 → UB
- ✅ 방지 방법:

```c
free(ptr);
ptr = NULL;  // 이후 free(NULL);은 안전
```

---

## 🔹 9. 메모리 해제의 타이밍 기준

- `free()`는 **더 이상 그 메모리를 사용하지 않을 시점에 정확히 한 번만** 호출
- 💣 너무 일찍: 이후 사용 시 충돌
- 💧 너무 늦게: 메모리 누수 발생
- 🧭 `malloc()`과 `free()`의 **책임 주체(소유권)**를 명확히 설계해야 함

---

## 🔹 10. 기타 고급 개념

- `malloc`과 `free`는 **시스템 콜 기반의 힙 메모리 관리자**와 연동됨
- 내부적으로는 **블록 앞뒤의 메타데이터**, **프리 리스트**, **병합 정보** 등을 사용
- 잘못된 `free()`는
  - **힙 관리자 자체의 무결성**을 깨뜨릴 수 있음
  - 전체 프로그램을 불안정하게 만들 수 있음

---



📝 생각 정리

문단속을 한다는건 문을 잠그고나서 여러 창문들과 문이 빠짐없이 잘 잠겼는지, 안전장치는 튼튼한지 등을 다시한번 확인하는 것이다.
그렇게 다시 한번 확인하는 절차가 여러번이면 분명 비효율일수도 있겠지만, 그만큼 안전성은 높아지는 것인데,
✔ free() 는 **한 번만 정확하게 해제해야 하는 작업**이기 때문에, 
✔ **'중복 확인 = 안전'** 이라는 일반 상식이 정반대 효과를 낸다.

단순하게만 생각하면, '응? 해제한거 다시한번 확인해서 해제 안되어있으면 또 해제하면 되는건데, 뭐가문제지?'
이런 의문이 들 수 있는데, 

우선 malloc 도 그렇고 free 가 어떤것을 다루는 함수인지 생각해보자.
바로 **메모리를 다루는 함수**들이다.

✔ malloc()과 free()는 **"메모리 관리자에게 요청하는 시스템 호출 성격의 함수들"**이다.

malloc()은 어떤 메모리 공간을 어떤 변수에게 할당해주는 것이고,
free()는 그 공간에 다시 접근해서 변수로부터 그 공간을 회수해오는 것이다.

좀더 정확하게 표현하자면
✔ malloc()은 **"어떤 공간을 요청해서 그 주소를 반환"**
✔ free()는 **"그 주소를 넘겨받고, 시스템 내부 메모리 리스트에서 다시 반납 처리"** 하는 것이다.

✔ free() 그 공간을 다시 쓸수 있는 자원으로 만드는 것인데,

비유하자면
> 땅에 컨테이너를 이용해서 임시적으로 가건물을 만들어 놓고 그 건물에 주소를 부여했는데,  → malloc()
> 그 건물을 철거해서 더이상 그 주소가 가르키는 건물이 없어지는 것이다.              → free()
> 그럼 그 땅은 다시 무엇이든 지을수 있는 빈 땅이 되는 것이다.

malloc() 과 free() 도 마찬가지로 어떤 변수에 특정 힙 메모리 공간을 할당해주고 다시 회수해오는건데,
메모리 해제를 하면 주소값은 아직 남아있지만 그 주소가 가리키는 대상이 사라져서
해당 주소는 **더 이상 안전하게 접근할 수 있는 주소가 아니다.**

근데 다시 free() 를 하면 접근할 수 있는 주소가 없기 때문에 오류가 나는 것이다.

free(ptr) 내부는 실제로 ptr이 가리키는 메모리 블록 앞/뒤에 붙은 메타데이터 영역에 접근하는데,
이 메타데이터가 손상되었거나, 이미 해제되었거나, 포인터가 이상하면 **힙 관리자 시스템 자체가 망가진다.**

