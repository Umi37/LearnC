# `memcpy`와 `memmove`에 대한 정리

## 1. memcpy

### 정의

`memcpy`는 메모리 블록을 복사하는 표준 C 라이브러리 함수이다.

`src`(원본) 메모리 영역에서 `dst`(목적지) 메모리 영역으로 지정한 크기(`n` 바이트)만큼 복사한다.

### 사용 방법

```c

#include <string.h>

void *memcpy(void *restrict dst, const void *restrict src, size_t n);

```

### 특징

- `src`와 `dst`가 **겹치지 않는 경우**에만 안전하게 사용할 수 있다.
- 복사하는 동안 순차적으로 복사가 진행되며, **복사 순서를 고려하지 않는다**.
- 두 메모리 영역이 겹치는 경우, 원본 데이터가 손상될 수 있으며, 이는 **정의되지 않은 동작(Undefined Behavior)** 을 초래한다.
- 복사 완료 후, **`dst` 포인터**를 반환한다.

### 주의 사항

- `dst`와 `src`가 겹칠 가능성이 있는 경우 `memcpy`를 사용해서는 안 된다.
- 겹칠 가능성이 있다면 `memmove`를 사용해야 한다.

---

## 2. memmove

### 정의

`memmove`는 메모리 블록을 복사하는 함수로, 복사 대상과 원본 메모리 영역이 **겹치는 경우에도 안전하게 복사**할 수 있도록 설계된 함수이다.

### 사용 방법

```c

#include <string.h>

void *memmove(void *dst, const void *src, size_t n);

```

### 특징

- `src`와 `dst`가 겹치더라도 **데이터가 손상되지 않도록 복사 순서를 조정**한다.
- 복사할 메모리 영역이 겹치는 경우, **뒤쪽에서 앞으로 복사**하는 방식으로 원본 데이터 손상을 방지한다.
- 복사 완료 후, **`dst` 포인터**를 반환한다.

### 내부 동작 방식

- `dst > src` (목적지가 원본보다 뒤쪽일 경우)에는 **뒤에서부터 복사**한다.
- `dst <= src` (목적지가 원본과 같거나 앞쪽일 경우)에는 **앞에서부터 복사**한다.

### 장단점

| 항목 | memcpy | memmove |
| --- | --- | --- |
| 복사 속도 | 빠름 | 느릴 수 있음 (겹침 여부 검사 및 복사 방향 조정) |
| 안전성 | 겹칠 경우 위험 | 겹쳐도 안전 |

---

## 3. memcpy와 memmove 사용 시 주의점

- 두 메모리 영역이 **겹치지 않는다면** `memcpy`를 사용하는 것이 성능상 이점이 있다.
- 두 메모리 영역이 **겹칠 가능성이 있는 경우** 반드시 `memmove`를 사용해야 한다.
- 복사할 데이터의 크기(`n`)를 정확하게 지정하고, 복사 대상 버퍼의 크기가 충분한지 확인해야 한다. (버퍼 오버플로우 방지)

---

## 4. 예시 코드

### 안전하지 않은 memcpy 사용 예시

```c

char buffer[20] = "Hello, World!";
memcpy(buffer + 3, buffer, 5); // 겹치는 영역 복사 → 정의되지 않은 동작 발생 가능

```

### 안전한 memmove 사용 예시

```c

char buffer[20] = "Hello, World!";
memmove(buffer + 3, buffer, 5); // 겹치는 영역 복사 → 안전하게 처리됨

```

---

## 5. 결론

`memcpy`는 빠르지만, 겹치는 메모리 복사에는 사용하면 안 된다.

겹침이 의심되는 경우에는 항상 `memmove`를 사용하여 데이터 손상을 예방해야 한다.

프로그램의 안정성과 신뢰성을 보장하기 위해서는 메모리 복사 함수의 특성과 동작 방식을 명확히 이해하고 사용하는 것이 필수적이다.